<?php

namespace InfoCounterparty\Compra;

use InfoCounterparty\ApiMethodAbstract;
use InfoCounterparty\SourceInfoCounterpartyAbstract;
use phpDocumentor\Reflection\DocBlock\Tags\Return_;

class CompraApi extends SourceInfoCounterpartyAbstract
{
    private static $ListMethod = array();
    private static $TranslateDictionary = array();

    private static $MessageDescription = [
        "not-found" => 'БИН/ИИН не найден',
        "incorrect_format" => 'Некорректный формат БИН/ИИН',
        "token-not-found" => 'Некорректный токен',
        "token-not-provided" => 'Токен не указан в запросе',
        "expired-or-too-early" => 'Срок действия токена истек',
        "Исчерпано количество запросов" => 'reached-limit',
        "Нет прав доступа на запрашиваемый ресурс" => 'requested-path-not-allowed',
    ];

    function __construct(string $apiToken, $options = array())
    {
        parent::__construct($apiToken, $options);
        self::$ListMethod = include(__DIR__ . '/ListMethods.php');

    }

    function Get(string &$identifier, &$method = array(), &$inCash = true)
    {
        if (empty($method))
            return false;
        try {
            if (is_array($method)) {
                $ret = [];
                foreach ($method as $met => $value) {
                    $ret[$met] = $this->Get($identifier, $met, $inCash);
                }
                return $ret;
            }
            if (is_string($method) &&
                array_key_exists($method, self::$ListMethod)) {
                /** @var $info ApiMethodAbstract */
                if (!class_exists(self::$ListMethod[$method]['class']))
                    throw new \Exception("Метод '{$method}' не реализован");
                $info = new self::$ListMethod[$method]['class'](
                    $this->apiToken,
                    $identifier,
                    $method,
                    self::$ListMethod[$method]);
                $info->useCache = $inCash;
                $val = $info->getInfo();
                return $this->RecurseForTranslate($method, $val);
            }
        } catch (\Exception $ex) {
            $msg = $ex->getMessage();
            if ($ex->getCode() == 100 && isset(self::$MessageDescription[$ex->getMessage()])) {
                $msg = self::$MessageDescription[$ex->getMessage()];
            }
            echo 'ERROR -> ' . $msg;
            return false;
        }
    }


    function Translate($metod, $Path)
    {
        if (empty(self::$TranslateDictionary) && file_exists(__DIR__ . '/TranslateDictionary/' . $metod . '.php')) {
            self::$TranslateDictionary = include(__DIR__ . '/TranslateDictionary/' . $metod . '.php');
        }
        if (isset(self::$TranslateDictionary[$Path]) && !empty(self::$TranslateDictionary[$Path]))
            return self::$TranslateDictionary[$Path]; // TODO: Change the autogenerated stub
        return null;
    }

    function RecurseForTranslate($method, $val)
    {
        static $path = array();
        $ret = null;
        if (is_array($val)) {
            foreach ($val as $key => $row) {
                if (is_array($row)) {
                    if (is_numeric($key))
                        array_push($path, '{D}');
                    else
                        array_push($path, $key);
                    $ret[$key] = $this->RecurseForTranslate($method, $row);
                    array_pop($path);
                } else {
                    array_push($path, $key);
                    $ret[$key] = ['value' => $row,
                        'title' => $this->Translate($method, implode('/', $path)),
                    ];
                    array_pop($path);
                }
            }
        }
        return $ret;
    }


    function GetListMethod()
    {
        if (!is_array(self::$ListMethod) || empty(self::$ListMethod))
            return false;
        $ret = array();
        foreach (self::$ListMethod as $key => $item) {
            $ret[$key]['title'] = $item['name'];
            $ret[$key]['description'] = $item['title'];
        }
        return $ret;

    }
}
